-- Supabase schema for Parascene (table prefix: prsn_)

-- Users table (base table, referenced by many others)
CREATE TABLE IF NOT EXISTS prsn_users (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email text UNIQUE NOT NULL,
  password_hash text NOT NULL,
  role text NOT NULL DEFAULT 'consumer',
  created_at timestamptz NOT NULL DEFAULT now(),
  last_active_at timestamptz,
  meta jsonb
);
ALTER TABLE prsn_users ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_users IS 'Parascene: user accounts with authentication credentials and roles. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- User profiles
CREATE TABLE IF NOT EXISTS prsn_user_profiles (
  user_id bigint PRIMARY KEY REFERENCES prsn_users(id) ON DELETE CASCADE,
  user_name text UNIQUE,
  display_name text,
  about text,
  socials jsonb,
  avatar_url text,
  cover_image_url text,
  badges jsonb,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_user_profiles ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_user_profiles IS 'Parascene: public profile fields (username, display name, bio, socials, avatar/cover URLs, badges, meta). RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Sessions
CREATE TABLE IF NOT EXISTS prsn_sessions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  token_hash text UNIQUE NOT NULL,
  expires_at timestamptz NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_sessions ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_sessions IS 'Parascene: user session tokens for authentication. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Moderation queue
CREATE TABLE IF NOT EXISTS prsn_moderation_queue (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  content_type text NOT NULL,
  content_id text NOT NULL,
  status text NOT NULL,
  reason text,
  created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_moderation_queue ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_moderation_queue IS 'Parascene: content moderation queue for reviewing user-generated content. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Servers
CREATE TABLE IF NOT EXISTS prsn_servers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  name text NOT NULL,
  server_url text NOT NULL,
  auth_token text,
  status text NOT NULL,
  status_date timestamptz,
  description text,
  members_count integer NOT NULL DEFAULT 0,
  server_config jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_servers ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_servers IS 'Parascene: consolidated provider servers table combining registry, status, and community server information. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- Server members
CREATE TABLE IF NOT EXISTS prsn_server_members (
  server_id bigint NOT NULL REFERENCES prsn_servers(id) ON DELETE CASCADE,
  user_id  bigint NOT NULL REFERENCES prsn_users(id)    ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (server_id, user_id)
);

ALTER TABLE prsn_server_members ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE prsn_server_members IS
  'Parascene: membership relationships between users and servers. RLS enabled without policies - only service role can access. All access controlled via API layer.';

CREATE INDEX IF NOT EXISTS idx_prsn_server_members_user_id
  ON prsn_server_members(user_id);


-- Policy knobs
CREATE TABLE IF NOT EXISTS prsn_policy_knobs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  key text NOT NULL,
  value text NOT NULL,
  description text,
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_policy_knobs ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_policy_knobs IS 'Parascene: system configuration and policy settings. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Notifications
CREATE TABLE IF NOT EXISTS prsn_notifications (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint REFERENCES prsn_users(id),
  role text,
  title text NOT NULL,
  message text NOT NULL,
  link text,
  actor_user_id bigint REFERENCES prsn_users(id),
  type text,
  target text,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  acknowledged_at timestamptz
);
ALTER TABLE prsn_notifications ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_notifications IS 'Parascene: user notifications, can be scoped by user_id or role. When type/actor/target/meta are set, message and link are resolved at read time from type. RLS enabled without policies - only service role can access. All access controlled via API layer.';



-- Email digest and engagement tracking
CREATE TABLE IF NOT EXISTS prsn_email_sends (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  campaign text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  meta jsonb
);
ALTER TABLE prsn_email_sends ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_email_sends IS 'Parascene: record of each lifecycle/digest email send for caps and analytics.';

CREATE TABLE IF NOT EXISTS prsn_email_user_campaign_state (
  user_id bigint PRIMARY KEY REFERENCES prsn_users(id),
  last_digest_sent_at timestamptz,
  welcome_email_sent_at timestamptz,
  first_creation_nudge_sent_at timestamptz,
  last_reengagement_sent_at timestamptz,
  last_creation_highlight_sent_at timestamptz,
  updated_at timestamptz NOT NULL DEFAULT now(),
  meta jsonb
);
ALTER TABLE prsn_email_user_campaign_state ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_email_user_campaign_state IS 'Parascene: per-user campaign state to avoid duplicate nudges.';

CREATE TABLE IF NOT EXISTS prsn_email_link_clicks (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email_send_id bigint NOT NULL REFERENCES prsn_email_sends(id),
  user_id bigint REFERENCES prsn_users(id),
  clicked_at timestamptz NOT NULL DEFAULT now(),
  path text,
  meta jsonb
);
ALTER TABLE prsn_email_link_clicks ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_email_link_clicks IS 'Parascene: link clicks from emails for effectiveness tracking.';


-- Explore items
CREATE TABLE IF NOT EXISTS prsn_explore_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title text NOT NULL,
  summary text NOT NULL,
  category text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_explore_items ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_explore_items IS 'Parascene: featured content items for the explore/discovery page. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Creations
CREATE TABLE IF NOT EXISTS prsn_creations (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  title text NOT NULL,
  body text NOT NULL,
  status text NOT NULL DEFAULT 'draft',
  created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_creations ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_creations IS 'Parascene: user-created content and artifacts. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Templates
CREATE TABLE IF NOT EXISTS prsn_templates (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category text NOT NULL,
  description text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_templates ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_templates IS 'Parascene: content templates available to users. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Created images
CREATE TABLE IF NOT EXISTS prsn_created_images (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  filename text NOT NULL,
  file_path text NOT NULL,
  width integer NOT NULL,
  height integer NOT NULL,
  color text,
  status text NOT NULL DEFAULT 'creating',
  created_at timestamptz NOT NULL DEFAULT now(),
  published boolean NOT NULL DEFAULT false,
  published_at timestamptz,
  title text,
  description text,
  meta jsonb,
  unavailable_at timestamptz
);
ALTER TABLE prsn_created_images ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_created_images IS 'Parascene: user-generated images with metadata and publication status. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- Anonymous (try) creations: prompt-pool and per-request images. try_requests links anon_cid to created_image_anon_id.
CREATE TABLE IF NOT EXISTS prsn_created_images_anon (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prompt text,
  filename text NOT NULL,
  file_path text NOT NULL,
  width integer NOT NULL,
  height integer NOT NULL,
  status text NOT NULL DEFAULT 'creating',
  created_at timestamptz NOT NULL DEFAULT now(),
  meta jsonb
);
CREATE INDEX IF NOT EXISTS idx_prsn_created_images_anon_prompt ON prsn_created_images_anon(prompt);
ALTER TABLE prsn_created_images_anon ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_created_images_anon IS 'Parascene: anonymous try-page images; try_requests links anon_cid to id. RLS enabled without policies - only service role can access.';

-- Try requests: one row per try create call, keyed by anon_cid. When anon image is transitioned to a user, created_image_anon_id is set NULL and meta.transitioned records where it went.
CREATE TABLE IF NOT EXISTS prsn_try_requests (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  anon_cid text NOT NULL,
  prompt text,
  created_at timestamptz NOT NULL DEFAULT now(),
  fulfilled_at timestamptz,
  created_image_anon_id bigint NULL,
  meta jsonb,
  CONSTRAINT fk_try_requests_created_image_anon
    FOREIGN KEY (created_image_anon_id) REFERENCES prsn_created_images_anon(id)
);
CREATE INDEX IF NOT EXISTS idx_prsn_try_requests_anon_cid ON prsn_try_requests(anon_cid);
CREATE INDEX IF NOT EXISTS idx_prsn_try_requests_created_image_anon_id ON prsn_try_requests(created_image_anon_id);
ALTER TABLE prsn_try_requests ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_try_requests IS 'Parascene: try-page requests by anon_cid; who requested, when, when fulfilled, which created_images_anon row served. meta reserved for future use.';


-- Feed items
CREATE TABLE IF NOT EXISTS prsn_feed_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title text NOT NULL,
  summary text NOT NULL,
  author text NOT NULL,
  tags text,
  created_at timestamptz NOT NULL DEFAULT now(),
  created_image_id bigint REFERENCES prsn_created_images(id)
);
ALTER TABLE prsn_feed_items ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_feed_items IS 'Parascene: feed items for the main content feed, can reference created images. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- User credits
CREATE TABLE IF NOT EXISTS prsn_user_credits (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL UNIQUE REFERENCES prsn_users(id),
  balance double precision NOT NULL DEFAULT 0,
  last_daily_claim_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_user_credits ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_user_credits IS 'Parascene: user credit balances and daily claim tracking. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- Tip activity: logs credits tipped between users (optionally tied to a created image)
CREATE TABLE IF NOT EXISTS prsn_tip_activity (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  from_user_id bigint NOT NULL REFERENCES prsn_users(id),
  to_user_id bigint NOT NULL REFERENCES prsn_users(id),
  created_image_id bigint REFERENCES prsn_created_images(id),
  amount double precision NOT NULL,
  message text,
  source text,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_tip_activity ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_tip_activity IS 'Parascene: tipping activity between users, optionally scoped to a creation.';

CREATE INDEX IF NOT EXISTS prsn_tip_activity_created_image_id_created_at_idx
  ON prsn_tip_activity (created_image_id, created_at);

CREATE INDEX IF NOT EXISTS prsn_tip_activity_to_user_id_created_at_idx
  ON prsn_tip_activity (to_user_id, created_at);

-- Atomic credit transfer function (no ledger table; balances only)
CREATE OR REPLACE FUNCTION prsn_transfer_credits(
  from_user_id bigint,
  to_user_id bigint,
  amount double precision
)
RETURNS TABLE(from_balance double precision, to_balance double precision)
LANGUAGE plpgsql
SET search_path = pg_catalog, public
AS $$
DECLARE
  sender_balance double precision;
BEGIN
  IF from_user_id IS NULL OR to_user_id IS NULL THEN
    RAISE EXCEPTION 'from_user_id and to_user_id are required';
  END IF;

  IF from_user_id = to_user_id THEN
    RAISE EXCEPTION 'cannot tip yourself';
  END IF;

  IF amount IS NULL OR amount <= 0 OR amount <> amount THEN
    RAISE EXCEPTION 'invalid amount';
  END IF;

  -- Ensure both users have a credits row
  INSERT INTO public.prsn_user_credits (user_id, balance)
    VALUES (from_user_id, 0)
    ON CONFLICT (user_id) DO NOTHING;
  INSERT INTO public.prsn_user_credits (user_id, balance)
    VALUES (to_user_id, 0)
    ON CONFLICT (user_id) DO NOTHING;

  -- Lock sender row to prevent concurrent overdrafts
  SELECT balance
    INTO sender_balance
    FROM public.prsn_user_credits
    WHERE user_id = from_user_id
    FOR UPDATE;

  IF sender_balance < amount THEN
    RAISE EXCEPTION 'insufficient credits';
  END IF;

  UPDATE public.prsn_user_credits
    SET balance = balance - amount,
        updated_at = now()
    WHERE user_id = from_user_id;

  UPDATE public.prsn_user_credits
    SET balance = balance + amount,
        updated_at = now()
    WHERE user_id = to_user_id;

  RETURN QUERY
    SELECT
      (SELECT balance FROM public.prsn_user_credits WHERE user_id = from_user_id),
      (SELECT balance FROM public.prsn_user_credits WHERE user_id = to_user_id);
END;
$$;

-- Hardening: if Supabase's helper trigger exists, pin its search_path too (addresses Security Advisor warning).
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'update_updated_at_column'
  ) THEN
    EXECUTE 'ALTER FUNCTION public.update_updated_at_column() SET search_path TO ''pg_catalog, public''';
  END IF;
END
$$;


-- User follows
CREATE TABLE IF NOT EXISTS prsn_user_follows (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  follower_id bigint NOT NULL REFERENCES prsn_users(id) ON DELETE CASCADE,
  following_id bigint NOT NULL REFERENCES prsn_users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(follower_id, following_id),
  CHECK(follower_id != following_id)
);
CREATE INDEX IF NOT EXISTS prsn_user_follows_follower_id_idx
  ON prsn_user_follows(follower_id);
CREATE INDEX IF NOT EXISTS prsn_user_follows_following_id_idx
  ON prsn_user_follows(following_id);
ALTER TABLE prsn_user_follows ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_user_follows IS 'Parascene: user follow relationships. RLS enabled without policies - only service role can access. All access controlled via API layer.';


-- Likes on created images
CREATE TABLE IF NOT EXISTS prsn_likes_created_image (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  created_image_id bigint NOT NULL REFERENCES prsn_created_images(id),
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(user_id, created_image_id)
);
ALTER TABLE prsn_likes_created_image ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_likes_created_image IS 'Parascene: user likes on created images. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- View: aggregated like counts per created image
DROP VIEW IF EXISTS public.prsn_created_image_like_counts;
CREATE VIEW public.prsn_created_image_like_counts
SECURITY INVOKER
AS
SELECT
  created_image_id,
  COUNT(*)::bigint AS like_count
FROM public.prsn_likes_created_image
GROUP BY created_image_id;
COMMENT ON VIEW public.prsn_created_image_like_counts IS 'Parascene: aggregated like counts per created image. SECURITY INVOKER view; access restricted via grants. All access controlled via API layer.';
REVOKE ALL ON TABLE public.prsn_created_image_like_counts FROM PUBLIC, anon, authenticated;
GRANT SELECT ON TABLE public.prsn_created_image_like_counts TO service_role;


-- Comments on created images
CREATE TABLE IF NOT EXISTS prsn_comments_created_image (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES prsn_users(id),
  created_image_id bigint NOT NULL REFERENCES prsn_created_images(id),
  text text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS prsn_comments_created_image_created_image_id_created_at_idx
  ON prsn_comments_created_image (created_image_id, created_at);
CREATE INDEX IF NOT EXISTS prsn_comments_created_image_user_id_idx
  ON prsn_comments_created_image (user_id);
ALTER TABLE prsn_comments_created_image ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_comments_created_image IS 'Parascene: user comments on created images. RLS enabled without policies - only service role can access. All access controlled via API layer.';

-- View: aggregated comment counts per created image
DROP VIEW IF EXISTS public.prsn_created_image_comment_counts;
CREATE VIEW public.prsn_created_image_comment_counts
SECURITY INVOKER
AS
SELECT
  created_image_id,
  COUNT(*)::bigint AS comment_count
FROM public.prsn_comments_created_image
GROUP BY created_image_id;
COMMENT ON VIEW public.prsn_created_image_comment_counts IS 'Parascene: aggregated comment counts per created image. SECURITY INVOKER view; access restricted via grants. All access controlled via API layer.';
REVOKE ALL ON TABLE public.prsn_created_image_comment_counts FROM PUBLIC, anon, authenticated;
GRANT SELECT ON TABLE public.prsn_created_image_comment_counts TO service_role;

-- Related creations: view→next-click transitions for click-next ranking
CREATE TABLE IF NOT EXISTS prsn_related_transitions (
  from_created_image_id bigint NOT NULL REFERENCES prsn_created_images(id) ON DELETE CASCADE,
  to_created_image_id bigint NOT NULL REFERENCES prsn_created_images(id) ON DELETE CASCADE,
  count bigint NOT NULL DEFAULT 1,
  last_updated timestamptz NOT NULL DEFAULT now(),
  UNIQUE(from_created_image_id, to_created_image_id),
  CHECK(from_created_image_id != to_created_image_id)
);
CREATE INDEX IF NOT EXISTS idx_prsn_related_transitions_from
  ON prsn_related_transitions(from_created_image_id);
CREATE INDEX IF NOT EXISTS idx_prsn_related_transitions_from_last_updated
  ON prsn_related_transitions(from_created_image_id, last_updated);
CREATE INDEX IF NOT EXISTS idx_prsn_related_transitions_count
  ON prsn_related_transitions(count DESC);
ALTER TABLE prsn_related_transitions ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_related_transitions IS 'Parascene: aggregated view→next-click transitions for related creations ranking. RLS enabled without policies - only service role can access.';

-- pgvector: semantic embeddings for creations (CLIP, 768 dims)
CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE IF NOT EXISTS prsn_created_embeddings (
  created_image_id bigint PRIMARY KEY REFERENCES prsn_created_images(id) ON DELETE CASCADE,
  embedding_text vector(768),
  embedding_image vector(768),
  embedding_multi vector(768),
  model text,
  meta jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
ALTER TABLE prsn_created_embeddings ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_created_embeddings IS 'Parascene: CLIP embeddings for semantic relatedness (pgvector). embedding_text = text-only, embedding_image = image-only, embedding_multi = text+image. One row per creation. RLS enabled without policies - only service role can access.';

-- RPC: nearest neighbours by embedding_multi (cosine distance). Used by API for semantic related + search.
-- off = offset for pagination (0-based). Drop old 3-arg overload if present so the name is unique.
DROP FUNCTION IF EXISTS prsn_created_embeddings_nearest(vector(768), bigint, int);
CREATE OR REPLACE FUNCTION prsn_created_embeddings_nearest(
  target_embedding vector(768),
  exclude_id bigint DEFAULT NULL,
  lim int DEFAULT 10,
  off int DEFAULT 0
)
RETURNS TABLE(created_image_id bigint, distance float)
LANGUAGE sql
STABLE
AS $$
  SELECT e.created_image_id, (e.embedding_multi <=> target_embedding)::float AS distance
  FROM prsn_created_embeddings e
  WHERE e.embedding_multi IS NOT NULL
    AND (exclude_id IS NULL OR e.created_image_id != exclude_id)
  ORDER BY e.embedding_multi <=> target_embedding
  OFFSET GREATEST(0, off)
  LIMIT GREATEST(1, LEAST(100, lim));
$$;
COMMENT ON FUNCTION prsn_created_embeddings_nearest(vector(768), bigint, int, int) IS 'Parascene: nearest creations by embedding_multi (cosine distance). Supports offset for paging.';

-- Search embedding cache: avoid Replicate calls for repeated text queries. Cull by daily usage.
CREATE TABLE IF NOT EXISTS prsn_search_embedding_cache (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  normalized_query text NOT NULL UNIQUE,
  embedding vector(768) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_prsn_search_embedding_cache_normalized ON prsn_search_embedding_cache(normalized_query);
ALTER TABLE prsn_search_embedding_cache ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_search_embedding_cache IS 'Parascene: cached CLIP embeddings for semantic search queries (normalized text). Cull by usage.';

CREATE TABLE IF NOT EXISTS prsn_search_embedding_cache_usage (
  cache_id bigint NOT NULL REFERENCES prsn_search_embedding_cache(id) ON DELETE CASCADE,
  day date NOT NULL,
  count int NOT NULL DEFAULT 0,
  PRIMARY KEY (cache_id, day)
);
CREATE INDEX IF NOT EXISTS idx_prsn_search_embedding_cache_usage_day ON prsn_search_embedding_cache_usage(day);
ALTER TABLE prsn_search_embedding_cache_usage ENABLE ROW LEVEL SECURITY;
COMMENT ON TABLE prsn_search_embedding_cache_usage IS 'Parascene: daily use counts for search embedding cache; used for culling low-use entries.';

CREATE OR REPLACE FUNCTION prsn_search_embedding_cache_record_usage(p_cache_id bigint)
RETURNS void
LANGUAGE sql
AS $$
  INSERT INTO prsn_search_embedding_cache_usage (cache_id, day, count)
  VALUES (p_cache_id, current_date, 1)
  ON CONFLICT (cache_id, day) DO UPDATE SET count = prsn_search_embedding_cache_usage.count + 1;
$$;
COMMENT ON FUNCTION prsn_search_embedding_cache_record_usage IS 'Parascene: increment daily usage for a cache entry (call on each cache hit or after storing new entry).';

-- Optional: run periodically to drop cache entries with low usage in the last N days.
CREATE OR REPLACE FUNCTION prsn_search_embedding_cache_cull(
  window_days int DEFAULT 30,
  min_uses_in_window int DEFAULT 2
)
RETURNS bigint
LANGUAGE sql
AS $$
  WITH candidates AS (
    SELECT c.id
    FROM prsn_search_embedding_cache c
    LEFT JOIN (
      SELECT cache_id, sum(count) AS total
      FROM prsn_search_embedding_cache_usage
      WHERE day >= current_date - window_days
      GROUP BY cache_id
    ) u ON u.cache_id = c.id
    WHERE coalesce(u.total, 0) < min_uses_in_window
  ),
  deleted AS (
    DELETE FROM prsn_search_embedding_cache WHERE id IN (SELECT id FROM candidates)
    RETURNING id
  )
  SELECT count(*)::bigint FROM deleted;
$$;
COMMENT ON FUNCTION prsn_search_embedding_cache_cull IS 'Parascene: delete cache entries whose usage in the last window_days is below min_uses_in_window. Returns number deleted. Run from cron or manually.';
